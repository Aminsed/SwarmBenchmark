src:

src/Particle.cpp:

<src/Particle.cpp>
#include "Particle.h"

Particle::Particle(double x, double y) : position{x, y}, bestPosition{x, y} {
    bestValue = std::numeric_limits<double>::infinity(); // Ensuring bestValue is properly initialized
}

void Particle::updateVelocity(const std::pair<double, double>& globalBestPosition, double inertiaWeight, double cognitiveWeight, double socialWeight, double randP, double randG) {
    velocity.first = inertiaWeight * velocity.first +
                     cognitiveWeight * randP * (bestPosition.first - position.first) +
                     socialWeight * randG * (globalBestPosition.first - position.first);
    velocity.second = inertiaWeight * velocity.second +
                      cognitiveWeight * randP * (bestPosition.second - position.second) +
                      socialWeight * randG * (globalBestPosition.second - position.second);
}

void Particle::updatePosition() {
    position.first += velocity.first;
    position.second += velocity.second;
}

void Particle::evaluateBestPosition(std::function<double(double, double)> objectiveFunc) {
    double value = objectiveFunc(position.first, position.second);
    if (value < bestValue) {
        bestValue = value;
        bestPosition = position;
    }
}

std::pair<double, double> Particle::getPosition() const {
    return position;
}

std::pair<double, double> Particle::getBestPosition() const {
    return bestPosition;
}

double Particle::getBestValue() const {
    return bestValue;
}
</src/Particle.cpp>

src/Swarm.cpp:

<src/Swarm.cpp>
#include "Swarm.h"
#include <iostream>
#include <random>

Swarm::Swarm(size_t size, double searchSpaceMin, double searchSpaceMax, std::function<double(double, double)> objectiveFunc)
    : objectiveFunc(objectiveFunc), searchSpaceMin(searchSpaceMin), searchSpaceMax(searchSpaceMax), dis(searchSpaceMin, searchSpaceMax) {
    std::random_device rd;
    gen.seed(rd());
    for (size_t i = 0; i < size; ++i) {
        particles.emplace_back(Particle(randomDouble(), randomDouble()));
    }
    initialize();
}

void Swarm::initialize() {
    for (auto& particle : particles) {
        particle.evaluateBestPosition(objectiveFunc);
        updateGlobalBest();
    }
}

void Swarm::optimize(int maxIterations) {
    const double inertiaWeight = 0.729, cognitiveWeight = 1.49445, socialWeight = 1.49445;

    for (int iter = 0; iter < maxIterations; ++iter) {
        for (auto& particle : particles) {
            double randP = randomDouble(), randG = randomDouble();
            particle.updateVelocity(globalBestPosition, inertiaWeight, cognitiveWeight, socialWeight, randP, randG);
            particle.updatePosition();
            particle.evaluateBestPosition(objectiveFunc);
            updateGlobalBest();
        }
    }
}

void Swarm::printGlobalBest() const {
    std::cout << "Global Best Position: (" << globalBestPosition.first << ", " << globalBestPosition.second << ")\n";
    std::cout << "Global Best Value: " << globalBestValue << std::endl;
}

void Swarm::updateGlobalBest() {
    for (auto& particle : particles) {
        if (particle.getBestValue() < globalBestValue) {
            globalBestValue = particle.getBestValue();
            globalBestPosition = particle.getBestPosition();
        }
    }
}

double Swarm::randomDouble() {
    return dis(gen);
}

</src/Swarm.cpp>

src/main.cpp:

<src/main.cpp>
#include "Swarm.h"
#include "ObjectiveFunction.h"
#include <iostream>
#include <chrono>

int main() {
    size_t swarmSize = 100;
    double searchSpaceMin = -5.12, searchSpaceMax = 5.12;
    int maxIterations = 1000;

    Swarm swarm(swarmSize, searchSpaceMin, searchSpaceMax, ObjectiveFunction::rastrigin);

    swarm.initialize();

    // Start the timer
    auto start = std::chrono::high_resolution_clock::now();

    swarm.optimize(maxIterations);

    // Stop the timer
    auto end = std::chrono::high_resolution_clock::now();

    // Calculate the duration
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    swarm.printGlobalBest();

    // Print the execution time
    std::cout << "Execution Time: " << duration.count() << " milliseconds" << std::endl;

    return 0;
}

</src/main.cpp>


include:

include/ObjectiveFunction.h:

<include/ObjectiveFunction.h>
#ifndef OBJECTIVE_FUNCTION_H
#define OBJECTIVE_FUNCTION_H

#include <cmath>

class ObjectiveFunction {
public:
    static double rastrigin(double x, double y) {
        return 20 + (x*x - 10*cos(2*M_PI*x)) + (y*y - 10*cos(2*M_PI*y));
    }
};

#endif // OBJECTIVE_FUNCTION_H

</include/ObjectiveFunction.h>

include/Swarm.h:

<include/Swarm.h>
#ifndef SWARM_H
#define SWARM_H

#include "Particle.h"
#include <vector>
#include <random>
#include <functional>

class Swarm {
public:
    Swarm(size_t size, double searchSpaceMin, double searchSpaceMax, std::function<double(double, double)> objectiveFunc);
    void initialize();
    void optimize(int maxIterations);
    void printGlobalBest() const;

private:
    std::vector<Particle> particles;
    std::pair<double, double> globalBestPosition;
    double globalBestValue = std::numeric_limits<double>::infinity();
    std::function<double(double, double)> objectiveFunc;
    double searchSpaceMin, searchSpaceMax;

    std::mt19937 gen;
    std::uniform_real_distribution<> dis;

    void updateGlobalBest();
    double randomDouble();
};

#endif // SWARM_H
</include/Swarm.h>

include/Particle.h:

<include/Particle.h>
#ifndef PARTICLE_H
#define PARTICLE_H

#include <utility>
#include <cmath>
#include <limits>
#include <functional>

class Particle {
public:
    Particle(double x, double y);
    void updateVelocity(const std::pair<double, double>& globalBestPosition, double inertiaWeight, double cognitiveWeight, double socialWeight, double randP, double randG);
    void updatePosition();
    void evaluateBestPosition(std::function<double(double, double)> objectiveFunc);

    std::pair<double, double> getPosition() const;
    std::pair<double, double> getBestPosition() const;
    double getBestValue() const;

private:
    std::pair<double, double> position;
    std::pair<double, double> velocity{0, 0};
    std::pair<double, double> bestPosition;
    double bestValue = std::numeric_limits<double>::infinity();
};

#endif // PARTICLE_H
</include/Particle.h>


Makefile:

<Makefile>
# Makefile for PSO_Project

CXX = g++
CXXFLAGS = -std=c++17 -Iinclude -Wall
SRC_DIR = src
INCLUDE_DIR = include
OBJ_DIR = obj
BIN_DIR = bin

SOURCES = $(wildcard $(SRC_DIR)/*.cpp)
OBJECTS = $(SOURCES:$(SRC_DIR)/%.cpp=$(OBJ_DIR)/%.o)
EXECUTABLE = $(BIN_DIR)/pso

all: $(EXECUTABLE)

$(EXECUTABLE): $(OBJECTS) | $(BIN_DIR)
	$(CXX) $(CXXFLAGS) $^ -o $@

$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp | $(OBJ_DIR)
	$(CXX) $(CXXFLAGS) -c $< -o $@

$(BIN_DIR) $(OBJ_DIR):
	mkdir -p $@

clean:
	rm -rf $(OBJ_DIR) $(BIN_DIR)

.PHONY: all clean
</Makefile>

